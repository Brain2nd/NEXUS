%==============================================================================
% SECTION 4: FLOATING-POINT ARITHMETIC
%==============================================================================

\subsection{Floating-Point Arithmetic Operations}
\label{sec:arithmetic}

This section describes how IEEE 754 floating-point arithmetic operations are implemented using SNN logic gates. Each operation processes the sign, exponent, and mantissa fields separately using the gates defined in Section~\ref{sec:gates}.

\subsubsection{Floating-Point Addition}
\label{sec:fp_add}

Floating-point addition is the most complex arithmetic operation, requiring exponent alignment, mantissa addition, and normalization.

\paragraph{Algorithm Overview}
Given two floating-point numbers $a = (-1)^{s_a} \times 2^{e_a} \times m_a$ and $b = (-1)^{s_b} \times 2^{e_b} \times m_b$, the computation proceeds as: compare exponents ($d = e_a - e_b$) using SNN subtractor, align mantissas by right-shifting the smaller by $|d|$ bits, add or subtract aligned mantissas based on signs, normalize result to restore $1.xxx$ format while adjusting exponent, then apply IEEE 754 rounding.

\paragraph{Exponent Difference}
The exponent difference is computed using an $n_e$-bit SNN subtractor as given by Equation~\ref{eq:exp_diff}:

\begin{equation}
d = e_a - e_b = e_a + \overline{e_b} + 1
\label{eq:exp_diff}
\end{equation}
where $d$ denotes the exponent difference, $e_a, e_b$ denote the exponents of the two operands, and $\overline{e_b}$ denotes the bitwise NOT (one's complement) of $e_b$. Adding 1 completes the two's complement subtraction.

\paragraph{Mantissa Alignment}
The mantissa of the smaller number is right-shifted by $|d|$ positions using a barrel shifter constructed from MUX gates. For each shift amount $2^k$, the shifted mantissa bit is computed as given by Equation~\ref{eq:barrel_shift}:

\begin{equation}
m'_i = \text{MUX}(m_i, m_{i+2^k}, d_k)
\label{eq:barrel_shift}
\end{equation}
where $m'_i$ denotes the $i$-th bit of the shifted mantissa, $m_i$ denotes the original mantissa bit, and $d_k$ denotes the $k$-th bit of the shift amount controlling whether to shift by $2^k$ positions.

\paragraph{Mantissa Addition/Subtraction}
The operation type is determined by the sign bits as given by Equation~\ref{eq:add_op}:

\begin{equation}
\text{op} = \text{XOR}(s_a, s_b)
\label{eq:add_op}
\end{equation}
where $s_a, s_b$ denote the sign bits of the two operands, and $\text{op}$ denotes the operation flag. If $\text{op} = 0$ (same signs), add mantissas; if $\text{op} = 1$ (different signs), subtract.

\paragraph{Normalization}
The result mantissa may require normalization: for overflow ($m \geq 2$), right-shift by 1 and increment exponent; for underflow ($m < 1$), count leading zeros, left-shift, and decrement exponent. Leading zero count (LZC) is implemented using a priority encoder built from OR gates.

\subsubsection{Floating-Point Multiplication}
\label{sec:fp_mul}

Multiplication is structurally simpler than addition. The product is computed as given by Equation~\ref{eq:fp_mul}:

\begin{equation}
a \times b = (-1)^{s_a \oplus s_b} \times 2^{(e_a + e_b - \text{bias})} \times (m_a \times m_b)
\label{eq:fp_mul}
\end{equation}
where $s_a, s_b$ denote the sign bits, $e_a, e_b$ denote the exponents, $m_a, m_b$ denote the mantissas, and $\text{bias}$ denotes the exponent bias.

\paragraph{Sign Computation}
The result sign is computed using XOR as given by Equation~\ref{eq:mul_sign}:
\begin{equation}
s_r = \text{XOR}(s_a, s_b)
\label{eq:mul_sign}
\end{equation}
where $s_r$ denotes the result sign bit.

\paragraph{Exponent Addition}
The result exponent is computed as given by Equation~\ref{eq:mul_exp}:
\begin{equation}
e_r = e_a + e_b - \text{bias}
\label{eq:mul_exp}
\end{equation}
where $e_r$ denotes the result exponent. The bias subtraction prevents double-counting. This is implemented using SNN adders:
\begin{equation}
e_r = \text{Adder}(e_a, e_b) - \text{bias}
\end{equation}

\paragraph{Mantissa Multiplication}
For mantissas $m_a = 1.a_{n_m-1}\ldots a_0$ and $m_b = 1.b_{n_m-1}\ldots b_0$, the product is computed using an array of AND gates and adders as given by Equation~\ref{eq:mant_mul}:

\begin{equation}
m_a \times m_b = \sum_{i=0}^{n_m} \sum_{j=0}^{n_m} a_i \cdot b_j \cdot 2^{-(i+j)}
\label{eq:mant_mul}
\end{equation}
where $a_i, b_j$ denote the individual mantissa bits and $n_m$ denotes the number of mantissa bits. Each partial product $a_i \cdot b_j$ is computed with an AND gate. The partial products are accumulated using a tree of SNN adders.

\paragraph{Normalization}
Since $1 \leq m_a, m_b < 2$, the product satisfies $1 \leq m_a \times m_b < 4$. If $m_r \geq 2$, the result is normalized as given by Equation~\ref{eq:mul_norm}:
\begin{align}
m_r &\leftarrow m_r / 2 \quad \text{(right-shift by 1)} \nonumber \\
e_r &\leftarrow e_r + 1
\label{eq:mul_norm}
\end{align}
where $m_r$ denotes the result mantissa and $e_r$ denotes the result exponent.

\subsubsection{Floating-Point Division}
\label{sec:fp_div}

Division uses the Newton-Raphson method to compute the reciprocal as given by Equation~\ref{eq:div_formula}:

\begin{equation}
\frac{a}{b} = a \times \frac{1}{b}
\label{eq:div_formula}
\end{equation}
where the reciprocal $1/b$ is computed iteratively.

\paragraph{Newton-Raphson Reciprocal}
To find $x = 1/b$, we iterate using the formula given by Equation~\ref{eq:newton_recip}:

\begin{equation}
x_{n+1} = x_n (2 - b \cdot x_n)
\label{eq:newton_recip}
\end{equation}
where $x_n$ denotes the $n$-th approximation to the reciprocal and $b$ denotes the divisor mantissa. This converges quadratically. With a good initial estimate, 3-4 iterations achieve FP32 precision.

\paragraph{Initial Estimate}
The initial estimate uses a lookup table indexed by the high bits of the mantissa as given by Equation~\ref{eq:recip_init}:

\begin{equation}
x_0 \approx \frac{1}{m_b}
\label{eq:recip_init}
\end{equation}
where $m_b$ denotes the mantissa of the divisor. The table is precomputed and stored in SNN-compatible format.

\paragraph{Complete Division}
The computation proceeds as: compute sign ($s_r = \text{XOR}(s_a, s_b)$), compute exponent ($e_r = e_a - e_b + \text{bias}$), compute reciprocal of $m_b$ using Newton-Raphson, multiply ($m_r = m_a \times (1/m_b)$), then normalize the result.

\subsubsection{Floating-Point Square Root}
\label{sec:fp_sqrt}

Square root also uses Newton-Raphson iteration as given by Equation~\ref{eq:newton_sqrt}:

\begin{equation}
x_{n+1} = \frac{1}{2}\left(x_n + \frac{a}{x_n}\right)
\label{eq:newton_sqrt}
\end{equation}
where $x_n$ denotes the $n$-th approximation to $\sqrt{a}$ and $a$ denotes the input value.

\paragraph{Exponent Handling}
For $a = 2^e \times m$, the square root decomposes as given by Equation~\ref{eq:sqrt_decomp}:

\begin{equation}
\sqrt{a} = \sqrt{2^e \times m} = 2^{e/2} \times \sqrt{m}
\label{eq:sqrt_decomp}
\end{equation}
where $e$ denotes the exponent and $m$ denotes the mantissa. When $e$ is odd, the formula becomes:
\begin{equation}
\sqrt{a} = 2^{(e-1)/2} \times \sqrt{2m}
\label{eq:sqrt_odd}
\end{equation}

\paragraph{Initial Estimate}
The initial estimate for $\sqrt{m}$ (where $1 \leq m < 2$) is computed as given by Equation~\ref{eq:sqrt_init}:

\begin{equation}
x_0 = 0.5 + 0.5 \times m
\label{eq:sqrt_init}
\end{equation}
where $m$ denotes the mantissa value. This linear approximation provides a starting point within 25\% of the true value.

\paragraph{Complete Square Root}
The computation proceeds as: check sign (if $s = 1$, return NaN), decompose exponent ($e = 2q + r$ where $r \in \{0, 1\}$), adjust mantissa ($m' = m \times 2^r$), compute $\sqrt{m'}$ using Newton-Raphson, then set result exponent ($e_r = q + \text{bias}$).

\subsubsection{Special Value Handling}

All arithmetic operations handle IEEE 754 special values: zero (exponent and mantissa all zeros), infinity (exponent all ones, mantissa all zeros), NaN (exponent all ones, mantissa non-zero), and denormals (exponent all zeros, mantissa non-zero). Special value detection uses OR-reduction gates on exponent/mantissa fields as given by Equation~\ref{eq:special_detect}:

\begin{align}
\text{exp\_zero} &= \text{NOR}(e_{n_e-1}, \ldots, e_0) \nonumber \\
\text{exp\_max} &= \text{AND}(e_{n_e-1}, \ldots, e_0) \nonumber \\
\text{mant\_zero} &= \text{NOR}(m_{n_m-1}, \ldots, m_0)
\label{eq:special_detect}
\end{align}
where $e_{n_e-1}, \ldots, e_0$ denote the exponent bits, $m_{n_m-1}, \ldots, m_0$ denote the mantissa bits, $\text{exp\_zero}$ indicates all-zero exponent, $\text{exp\_max}$ indicates all-one exponent, and $\text{mant\_zero}$ indicates all-zero mantissa.

