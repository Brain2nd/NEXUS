%==============================================================================
% SECTION 2: PULSE ENCODING MECHANISM
%==============================================================================

\subsection{Pulse Encoding}
\label{sec:encoding}

This section describes how IEEE 754 floating-point numbers are encoded as binary pulse sequences using dynamic threshold GLIF neurons. The theoretical foundations for this encoding---including why soft reset is mandatory---are established in Section~\ref{sec:theory}.

\subsubsection{IEEE 754 Floating-Point Representation}

A floating-point number $x$ in IEEE 754 format is represented as given by Equation~\ref{eq:ieee754}:

\begin{equation}
x = (-1)^s \times 2^{e - \text{bias}} \times (1.m)
\label{eq:ieee754}
\end{equation}
where $s \in \{0, 1\}$ denotes the sign bit, $e$ denotes the unsigned exponent, $\text{bias} = 2^{n_e-1} - 1$ denotes the exponent bias (with $n_e$ being the number of exponent bits), and $m$ denotes the fractional mantissa with an implicit leading 1 for normalized numbers.

For FP32, the 32-bit representation is structured as shown in Equation~\ref{eq:fp32_struct}:

\begin{equation}
\underbrace{s}_{1} \underbrace{e_7 e_6 \cdots e_0}_{8} \underbrace{m_{22} m_{21} \cdots m_0}_{23}
\label{eq:fp32_struct}
\end{equation}
where $s$ denotes the 1-bit sign field, $e_7 e_6 \cdots e_0$ denotes the 8-bit exponent field, and $m_{22} m_{21} \cdots m_0$ denotes the 23-bit mantissa field.

\subsubsection{Pulse Sequence Representation}

A floating-point number is encoded as a pulse sequence $\pulse{x} = [p_0, p_1, \ldots, p_{n-1}]$, where each pulse $p_i \in \{0, 1\}$ corresponds to the $i$-th bit of the IEEE 754 representation as given by Equation~\ref{eq:pulse_struct}:

\begin{equation}
\pulse{x} = [s, e_{n_e-1}, \ldots, e_0, m_{n_m-1}, \ldots, m_0]
\label{eq:pulse_struct}
\end{equation}
where $s$ denotes the sign bit, $e_{n_e-1}, \ldots, e_0$ denote the exponent bits (from most to least significant), and $m_{n_m-1}, \ldots, m_0$ denote the mantissa bits. For FP32, this yields a 32-element binary vector. The pulse values are represented as floating-point tensors containing only 0.0 or 1.0 values.

\subsubsection{Dynamic Threshold GLIF Neuron}

The encoder uses a \textbf{dynamic threshold GLIF neuron} to extract bits from floating-point values. For bit-exact encoding, we use $\beta = 1$ (ideal IF mode). The dynamic threshold decreases by powers of 2 to extract successive bits via the SAR-ADC (Successive Approximation Register) algorithm.

\paragraph{Dynamics} The membrane potential $\membrane(t)$ evolves according to Equation~\ref{eq:encoder_dynamics}:

\begin{equation}
\membrane(t+1) = \beta \membrane(t) + I(t)
\label{eq:encoder_dynamics}
\end{equation}
where $\membrane(t)$ denotes the membrane potential at time $t$, $\beta$ denotes the decay factor ($\beta = 1$ for bit-exact mode), and $I(t)$ denotes the input current. The neuron fires when the condition in Equation~\ref{eq:encoder_fire} is satisfied:

\begin{equation}
\spike(t) = \heaviside(\membrane(t) - \threshold(t))
\label{eq:encoder_fire}
\end{equation}
where $\spike(t) \in \{0, 1\}$ denotes the spike output, $\threshold(t)$ denotes the dynamic threshold, and $\heaviside(\cdot)$ denotes the Heaviside step function.

\paragraph{Dynamic Threshold Schedule} As established in Lemma~\ref{lem:genericity}, the threshold at timestep $t$ follows the information-theoretically optimal SAR sequence given by Equation~\ref{eq:dynamic_threshold}:

\begin{equation}
\threshold(t) = 2^{n-1-t}
\label{eq:dynamic_threshold}
\end{equation}
where $n$ denotes the total number of bits to extract, and $t \in \{0, 1, \ldots, n-1\}$ denotes the timestep. This schedule extracts exactly 1 bit of information per timestep, from most significant to least significant.

\paragraph{Soft Reset} After firing, the membrane potential is updated according to the soft reset rule given by Equation~\ref{eq:soft_reset}:

\begin{equation}
\membrane(t+1) = \membrane(t) - \spike(t) \cdot \threshold(t)
\label{eq:soft_reset}
\end{equation}
where $\membrane(t)$ denotes the current membrane potential, $\spike(t)$ denotes the spike output (0 or 1), and $\threshold(t)$ denotes the current threshold. The soft reset is \textbf{mandatory} for the encoder (Lemma~\ref{lem:manifold}): it preserves the residual membrane potential, allowing subsequent bits to be extracted correctly. A hard reset ($\membrane \leftarrow 0$) would destroy the toroidal phase space topology and lose information.

\subsubsection{Encoding Algorithm}

For a positive floating-point value $v$ with $n$-bit representation:

\begin{enumerate}
    \item Initialize: $\membrane(0) = v$
    \item For $t = 0, 1, \ldots, n-1$:
    \begin{enumerate}
        \item Compute threshold: $\threshold(t) = 2^{n-1-t}$
        \item Generate spike: $\spike(t) = \heaviside(\membrane(t) - \threshold(t))$
        \item Update membrane: $\membrane(t+1) = \membrane(t) - \spike(t) \cdot \threshold(t)$
    \end{enumerate}
    \item Output: $\pulse{v} = [\spike(0), \spike(1), \ldots, \spike(n-1)]$
\end{enumerate}

\paragraph{Example} Encoding the value 5 with 4 bits:

\begin{align}
t=0: &\quad \threshold=8, \quad \membrane=5 < 8, \quad \spike=0 \\
t=1: &\quad \threshold=4, \quad \membrane=5 \geq 4, \quad \spike=1, \quad \membrane \leftarrow 1 \\
t=2: &\quad \threshold=2, \quad \membrane=1 < 2, \quad \spike=0 \\
t=3: &\quad \threshold=1, \quad \membrane=1 \geq 1, \quad \spike=1
\end{align}

Result: $\pulse{5} = [0, 1, 0, 1]_2 = 5_{10}$ \checkmark

\subsubsection{Sign Bit Handling}

For floating-point numbers, the sign bit requires special handling. The sign bit is extracted as given by Equation~\ref{eq:sign_extract}:

\begin{equation}
s = \heaviside(-x)
\label{eq:sign_extract}
\end{equation}
where $s \in \{0, 1\}$ denotes the sign bit, $x$ denotes the input floating-point value, and $\heaviside(\cdot)$ denotes the Heaviside step function. The absolute value $|x|$ is then encoded for the exponent and mantissa fields using the standard dynamic threshold mechanism. The sign bit is prepended to form the complete pulse sequence.

\subsubsection{Decoding}

The decoder reconstructs the floating-point value from the pulse sequence. This is a \textbf{boundary operation} where traditional arithmetic is permitted. The decoding formula is given by Equation~\ref{eq:decode}:

\begin{equation}
x = (-1)^{p_0} \times 2^{\sum_{i=1}^{n_e} p_i \cdot 2^{n_e-i} - \text{bias}} \times \left(1 + \sum_{j=1}^{n_m} p_{n_e+j} \cdot 2^{-j}\right)
\label{eq:decode}
\end{equation}
where $p_0$ denotes the sign bit, $p_1, \ldots, p_{n_e}$ denote the exponent bits, $p_{n_e+1}, \ldots, p_{n_e+n_m}$ denote the mantissa bits, $n_e$ denotes the number of exponent bits, $n_m$ denotes the number of mantissa bits, and $\text{bias}$ denotes the exponent bias. The decoder operates at the system boundary, converting pulse sequences back to floating-point for output.

