%==============================================================================
% SECTION 3: BASIC LOGIC GATES
%==============================================================================

\subsection{SNN Logic Gates}
\label{sec:gates}

This section presents the construction of Boolean logic gates using GLIF neurons. Each gate is implemented by choosing an appropriate threshold that produces the desired truth table.

\subsubsection{GLIF Neuron Model for Logic Gates}

For logic gates, we use GLIF neurons with $\beta = 1$ (ideal IF mode), fixed threshold $\threshold$, and soft reset. Consistent with the theoretical framework (Section~\ref{sec:theory}), soft reset is used throughout MofNeuroSim to maintain the toroidal phase space topology. The general gate output is given by Equation~\ref{eq:if_gate}:

\begin{equation}
y = \heaviside\left(\sum_i w_i x_i - \threshold\right)
\label{eq:if_gate}
\end{equation}
where $y \in \{0, 1\}$ denotes the gate output, $x_i \in \{0, 1\}$ denote the binary inputs, $w_i$ denote the synaptic weights, $\threshold$ denotes the firing threshold, and $\heaviside(\cdot)$ denotes the Heaviside step function defined by Equation~\ref{eq:heaviside}:

\begin{equation}
\heaviside(z) = \begin{cases} 1 & \text{if } z \geq 0 \\ 0 & \text{if } z < 0 \end{cases}
\label{eq:heaviside}
\end{equation}
where $z$ denotes the input argument.

\subsubsection{AND Gate}

The AND gate outputs 1 only when all inputs are 1. For two inputs with unit weights, the AND gate is defined by Equation~\ref{eq:and}:

\begin{equation}
\text{AND}(x_1, x_2) = \heaviside(x_1 + x_2 - 1.5)
\label{eq:and}
\end{equation}
where $x_1, x_2 \in \{0, 1\}$ denote the binary inputs, and the threshold $\threshold = 1.5$ ensures the neuron fires only when both inputs are active.

\paragraph{Verification}
\begin{align}
\text{AND}(0, 0) &= \heaviside(-1.5) = 0 \\
\text{AND}(0, 1) &= \heaviside(-0.5) = 0 \\
\text{AND}(1, 0) &= \heaviside(-0.5) = 0 \\
\text{AND}(1, 1) &= \heaviside(+0.5) = 1
\end{align}

\subsubsection{OR Gate}

The OR gate outputs 1 when at least one input is 1. The OR gate is defined by Equation~\ref{eq:or}:

\begin{equation}
\text{OR}(x_1, x_2) = \heaviside(x_1 + x_2 - 0.5)
\label{eq:or}
\end{equation}
where $x_1, x_2 \in \{0, 1\}$ denote the binary inputs, and the threshold $\threshold = 0.5$ ensures the neuron fires when at least one input is active.

\paragraph{Verification}
\begin{align}
\text{OR}(0, 0) &= \heaviside(-0.5) = 0 \\
\text{OR}(0, 1) &= \heaviside(+0.5) = 1 \\
\text{OR}(1, 0) &= \heaviside(+0.5) = 1 \\
\text{OR}(1, 1) &= \heaviside(+1.5) = 1
\end{align}

\subsubsection{NOT Gate}

The NOT gate inverts the input using an inhibitory connection. The NOT gate is defined by Equation~\ref{eq:not}:

\begin{equation}
\text{NOT}(x) = \heaviside(1 - x - 0.5) = \heaviside(0.5 - x)
\label{eq:not}
\end{equation}
where $x \in \{0, 1\}$ denotes the binary input. This can be interpreted as a neuron with a constant bias of 1, an inhibitory weight of $-1$, and threshold 0.5.

\paragraph{Verification}
\begin{align}
\text{NOT}(0) &= \heaviside(0.5) = 1 \\
\text{NOT}(1) &= \heaviside(-0.5) = 0
\end{align}

\subsubsection{XOR Gate}

The XOR gate cannot be implemented with a single neuron (it is not linearly separable). We implement it using a five-neuron network as given by Equation~\ref{eq:xor}:

\begin{equation}
\text{XOR}(a, b) = (a \land \lnot b) \lor (\lnot a \land b)
\label{eq:xor}
\end{equation}
where $a, b \in \{0, 1\}$ denote the binary inputs. This requires 2 NOT gates, 2 AND gates, and 1 OR gate.

\paragraph{Verification}
\begin{align}
\text{XOR}(0, 0) &= (0 \land 1) \lor (1 \land 0) = 0 \lor 0 = 0 \\
\text{XOR}(0, 1) &= (0 \land 0) \lor (1 \land 1) = 0 \lor 1 = 1 \\
\text{XOR}(1, 0) &= (1 \land 1) \lor (0 \land 0) = 1 \lor 0 = 1 \\
\text{XOR}(1, 1) &= (1 \land 0) \lor (0 \land 1) = 0 \lor 0 = 0
\end{align}

\subsubsection{Multiplexer (MUX) Gate}

The 2-to-1 multiplexer selects between two inputs based on a select signal. The MUX gate is defined by Equation~\ref{eq:mux}:

\begin{equation}
\text{MUX}(s, a, b) = \text{OR}(\text{AND}(s, a), \text{AND}(\text{NOT}(s), b))
\label{eq:mux}
\end{equation}
where $s \in \{0, 1\}$ denotes the select signal and $a, b \in \{0, 1\}$ denote the data inputs. When $s = 1$, the output is $a$; when $s = 0$, the output is $b$.

\subsubsection{Half Adder}

The half adder computes the sum and carry of two single-bit inputs as given by Equation~\ref{eq:half_adder}:

\begin{align}
\text{sum} &= \text{XOR}(a, b) \\
\text{carry} &= \text{AND}(a, b)
\label{eq:half_adder}
\end{align}
where $a, b \in \{0, 1\}$ denote the binary inputs, $\text{sum}$ denotes the sum bit, and $\text{carry}$ denotes the carry-out bit.

\subsubsection{Full Adder}

The full adder extends the half adder to include a carry input. The full adder is defined by Equation~\ref{eq:full_adder}:

\begin{align}
\text{sum} &= \text{XOR}(\text{XOR}(a, b), c_{in}) \\
\text{carry} &= \text{OR}(\text{AND}(a, b), \text{AND}(\text{XOR}(a, b), c_{in}))
\label{eq:full_adder}
\end{align}
where $a, b \in \{0, 1\}$ denote the binary inputs, $c_{in} \in \{0, 1\}$ denotes the carry-in, $\text{sum}$ denotes the sum output, and $\text{carry}$ denotes the carry-out. This produces:
\begin{equation}
a + b + c_{in} = 2 \cdot \text{carry} + \text{sum}
\end{equation}

\subsubsection{Multi-bit Adder}

An $n$-bit ripple-carry adder chains $n$ full adders as given by Equation~\ref{eq:ripple_adder}:

\begin{equation}
(\text{sum}_i, c_{i+1}) = \text{FullAdder}(a_i, b_i, c_i)
\label{eq:ripple_adder}
\end{equation}
where $a_i, b_i$ denote the $i$-th bits of the input operands, $c_i$ denotes the carry-in for bit $i$, $\text{sum}_i$ denotes the $i$-th sum bit, and $c_{i+1}$ denotes the carry-out. The index $i$ ranges from 0 to $n-1$, with $c_0 = 0$ for addition or $c_0 = 1$ for subtraction via two's complement.

\subsubsection{Comparator}

Comparison of two $n$-bit numbers uses cascaded single-bit comparators. For each bit position $i$ (from MSB to LSB), the comparison signals are computed as given by Equation~\ref{eq:comparator}:

\begin{align}
\text{gt}_i &= \text{AND}(a_i, \text{NOT}(b_i)) \nonumber \\
\text{lt}_i &= \text{AND}(\text{NOT}(a_i), b_i) \nonumber \\
\text{eq}_i &= \text{NOT}(\text{XOR}(a_i, b_i))
\label{eq:comparator}
\end{align}
where $a_i, b_i \in \{0, 1\}$ denote the $i$-th bits of the two operands, $\text{gt}_i$ denotes the greater-than signal, $\text{lt}_i$ denotes the less-than signal, and $\text{eq}_i$ denotes the equal signal. The final comparison result propagates from the most significant differing bit.

\subsubsection{Gate Summary}

Table~\ref{tab:gates} summarizes the logic gate implementations:

\begin{table}[t]
\centering
\caption{SNN Logic Gate Implementations}
\label{tab:gates}
\small
\begin{tabular}{@{}lccc@{}}
\toprule
\textbf{Gate} & \textbf{$\theta$} & \textbf{Formula} & \textbf{N} \\
\midrule
AND & 1.5 & $\heaviside(x_1 + x_2 - 1.5)$ & 1 \\
OR & 0.5 & $\heaviside(x_1 + x_2 - 0.5)$ & 1 \\
NOT & 0.5 & $\heaviside(0.5 - x)$ & 1 \\
XOR & -- & OR(AND, AND) & 5 \\
MUX & -- & OR(AND, AND) & 4 \\
\bottomrule
\end{tabular}
\end{table}

\subsubsection{Vectorized Gates}

For efficient batch processing, all gates support vectorized operations on pulse tensors. Given input tensors $\mathbf{A}, \mathbf{B} \in \{0, 1\}^{B \times N}$ (batch size $B$, $N$ bits), the vectorized gate applies element-wise as given by Equation~\ref{eq:vec_gate}:

\begin{equation}
\mathbf{Y}_{b,n} = \text{Gate}(\mathbf{A}_{b,n}, \mathbf{B}_{b,n})
\label{eq:vec_gate}
\end{equation}
where $\mathbf{Y}_{b,n}$ denotes the output at batch index $b$ and bit position $n$, $\mathbf{A}_{b,n}$ and $\mathbf{B}_{b,n}$ denote the corresponding input elements, and $\text{Gate}(\cdot, \cdot)$ denotes any binary gate operation. This enables parallel processing of multiple floating-point values and their bit representations.

